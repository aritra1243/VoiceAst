// VoiceAst Frontend - WebSocket Communication & UI Logic

class VoiceAssistant {
    constructor() {
        this.ws = null;
        this.isListening = false;
        this.recognition = null;
        this.commandHistory = [];
        this.typingInterval = null;
        this.wakeWordActive = false;

        this.initializeElements();
        this.connectWebSocket();
        this.loadHistory();
        this.loadStatistics();
    }

    initializeElements() {
        // Main elements
        this.statusDot = document.getElementById('statusDot');
        this.statusText = document.getElementById('statusText');
        this.micButton = document.getElementById('micButton');
        this.voiceVisualizer = document.getElementById('voiceVisualizer');
        this.voiceStatusText = document.getElementById('voiceStatusText');
        this.voiceSubtitle = document.getElementById('voiceSubtitle');

        // Transcription & Response
        this.transcriptionBox = document.getElementById('transcriptionBox');
        this.transcriptionText = document.getElementById('transcriptionText');
        this.responseBox = document.getElementById('responseBox');
        this.responseText = document.getElementById('responseText');
        this.responseStatus = document.getElementById('responseStatus');

        // History & Stats
        this.historyList = document.getElementById('historyList');
        this.statTotal = document.getElementById('statTotal');
        this.statSuccess = document.getElementById('statSuccess');

        // Event listeners
        this.micButton.addEventListener('click', () => this.toggleListening());

        // Keyboard shortcut (Space to talk)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !this.isListening && e.target === document.body) {
                e.preventDefault();
                this.startListening();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && this.isListening) {
                e.preventDefault();
                this.stopListening();
            }
        });
    }

    connectWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.hostname || 'localhost';
        const port = window.location.port || '8000';
        const wsUrl = `${protocol}//${host}:${port}/ws`;

        console.log('Connecting to WebSocket:', wsUrl);
        this.ws = new WebSocket(wsUrl);

        this.ws.onopen = () => {
            console.log('WebSocket connected');
            this.updateStatus('connected', 'Connected');
        };

        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleMessage(data);
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.updateStatus('error', 'Connection Error');
        };

        this.ws.onclose = () => {
            console.log('WebSocket disconnected');
            this.updateStatus('disconnected', 'Disconnected');

            // Attempt to reconnect after 3 seconds
            setTimeout(() => this.connectWebSocket(), 3000);
        };
    }

    updateStatus(status, text) {
        this.statusDot.className = `status-dot ${status}`;
        this.statusText.textContent = text;
    }

    handleMessage(data) {
        console.log('Received:', data);

        switch (data.type) {
            case 'connected':
                this.updateStatus('connected', 'Ready');
                break;

            case 'transcription':
                this.showTranscription(data.text);
                break;

            case 'processing':
                this.voiceStatusText.textContent = 'Processing...';
                this.voiceSubtitle.textContent = data.command;
                break;

            case 'intent':
                this.voiceStatusText.textContent = `Intent: ${data.intent}`;
                this.voiceSubtitle.textContent = `Confidence: ${(data.confidence * 100).toFixed(0)}%`;
                break;

            case 'result':
                this.showResponseTyping(data.message, data.success);
                this.addToHistory(this.transcriptionText.textContent, data.message, data.success);
                this.loadStatistics();
                break;

            case 'speaking':
                this.voiceStatusText.textContent = 'Speaking...';
                break;
        }
    }

    toggleListening() {
        if (this.isListening) {
            this.stopListening();
        } else {
            this.startListening();
        }
    }

    async startListening() {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            alert('Not connected to server. Please wait...');
            return;
        }

        try {
            // Use Web Speech API directly for recognition
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('Speech recognition not supported in this browser. Please use Chrome or Edge.');
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();

            recognition.lang = 'en-US';
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            this.isListening = true;
            this.micButton.classList.add('listening');
            this.voiceVisualizer.classList.add('active');
            this.voiceStatusText.textContent = 'Listening...';
            this.voiceSubtitle.textContent = 'Speak your command now';

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                console.log('Recognized:', transcript);
                this.sendCommand(transcript);
                this.stopListening();
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                this.voiceStatusText.textContent = 'Error: ' + event.error;
                this.voiceSubtitle.textContent = 'Please try again';
                this.stopListening();
            };

            recognition.onend = () => {
                this.stopListening();
            };

            recognition.start();

            // Store recognition object to stop it later if needed
            this.recognition = recognition;

        } catch (error) {
            console.error('Microphone error:', error);
            alert('Error accessing speech recognition: ' + error.message);
            this.stopListening();
        }
    }

    stopListening() {
        if (!this.isListening) return;

        this.isListening = false;
        this.micButton.classList.remove('listening');
        this.voiceVisualizer.classList.remove('active');

        if (this.recognition) {
            try {
                this.recognition.stop();
            } catch (e) {
                // Ignore errors when stopping
            }
            this.recognition = null;
        }
    }

    sendCommand(commandText) {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            alert('Not connected to server');
            return;
        }

        // Check for wake word "Hey Prime" or "Hi Prime"
        const lowerCommand = commandText.toLowerCase();
        if (lowerCommand.includes('hey prime') || lowerCommand.includes('hi prime') ||
            lowerCommand.includes('hello prime') || lowerCommand.includes('prime')) {
            this.wakeWordActive = true;

            // Extract command after wake word
            let actualCommand = commandText;
            const wakeWords = ['hey prime', 'hi prime', 'hello prime'];
            for (const wakeWord of wakeWords) {
                const index = lowerCommand.indexOf(wakeWord);
                if (index !== -1) {
                    actualCommand = commandText.substring(index + wakeWord.length).trim();
                    break;
                }
            }

            // If only wake word, greet
            if (!actualCommand || actualCommand.length < 3) {
                this.showTranscriptionTyping(commandText);
                this.showResponseTyping("Hello! I'm Prime, your voice assistant. How can I help you?", true);
                return;
            }

            commandText = actualCommand;
        }

        this.ws.send(JSON.stringify({
            type: 'voice_command',
            text: commandText
        }));

        this.showTranscriptionTyping(commandText);
    }

    showTranscription(text) {
        this.transcriptionText.textContent = text;
        this.transcriptionBox.classList.add('show');
    }

    showTranscriptionTyping(text) {
        this.transcriptionBox.classList.add('show');
        this.typeText(this.transcriptionText, text, 50);
    }

    showResponse(message, success) {
        this.responseText.textContent = message;
        this.responseStatus.textContent = success ? '✓ Success' : '✗ Failed';
        this.responseStatus.className = `response-status ${success ? 'success' : 'error'}`;
        this.responseBox.classList.add('show');

        // Reset voice status
        setTimeout(() => {
            this.voiceStatusText.textContent = 'Ready for next command';
            this.voiceSubtitle.textContent = 'Say "Hey Prime" to activate';
        }, 2000);
    }

    showResponseTyping(message, success) {
        this.responseBox.classList.add('show');
        this.responseStatus.textContent = success ? '✓ Success' : '✗ Failed';
        this.responseStatus.className = `response-status ${success ? 'success' : 'error'}`;
        this.typeText(this.responseText, message, 30);

        // Reset voice status
        setTimeout(() => {
            this.voiceStatusText.textContent = 'Ready for next command';
            this.voiceSubtitle.textContent = 'Say "Hey Prime" to activate';
        }, 2000);
    }

    typeText(element, text, speed = 50) {
        // Clear any existing typing
        if (this.typingInterval) {
            clearInterval(this.typingInterval);
        }

        element.textContent = '';
        const words = text.split(' ');
        let wordIndex = 0;

        this.typingInterval = setInterval(() => {
            if (wordIndex < words.length) {
                element.textContent += (wordIndex > 0 ? ' ' : '') + words[wordIndex];
                wordIndex++;
            } else {
                clearInterval(this.typingInterval);
                this.typingInterval = null;
            }
        }, speed);
    }

    addToHistory(command, response, success) {
        const historyItem = {
            command,
            response,
            success,
            timestamp: new Date().toISOString()
        };

        this.commandHistory.unshift(historyItem);

        // Limit history to 50 items
        if (this.commandHistory.length > 50) {
            this.commandHistory.pop();
        }

        this.renderHistory();
    }

    renderHistory() {
        if (this.commandHistory.length === 0) {
            this.historyList.innerHTML = '<div class="empty-state">No commands yet</div>';
            return;
        }

        this.historyList.innerHTML = this.commandHistory.map(item => {
            const time = new Date(item.timestamp).toLocaleTimeString();
            return `
                <div class="history-item ${item.success ? '' : 'error'}">
                    <div class="history-command">${this.escapeHtml(item.command)}</div>
                    <div class="history-response">${this.escapeHtml(item.response)}</div>
                    <div class="history-time">${time}</div>
                </div>
            `;
        }).join('');
    }

    async loadHistory() {
        try {
            const response = await fetch('/api/history?limit=20');
            const data = await response.json();

            if (data.history && data.history.length > 0) {
                this.commandHistory = data.history.map(item => ({
                    command: item.command,
                    response: item.response,
                    success: item.success,
                    timestamp: item.timestamp
                }));
                this.renderHistory();
            }
        } catch (error) {
            console.error('Error loading history:', error);
        }
    }

    async loadStatistics() {
        try {
            const response = await fetch('/api/statistics');
            const data = await response.json();

            this.statTotal.textContent = data.total_commands || 0;
            this.statSuccess.textContent = `${((data.success_rate || 0) * 100).toFixed(0)}%`;
        } catch (error) {
            console.error('Error loading statistics:', error);
        }
    }

    async clearHistory() {
        if (!confirm('Clear all command history?')) {
            return;
        }

        try {
            await fetch('/api/history/clear', { method: 'POST' });
            this.commandHistory = [];
            this.renderHistory();
            this.loadStatistics();
        } catch (error) {
            console.error('Error clearing history:', error);
        }
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// Global functions for HTML onclick handlers
let assistant;

function sendCommand(commandText) {
    assistant.sendCommand(commandText);
}

function clearHistory() {
    assistant.clearHistory();
}

function closeSettings() {
    document.getElementById('settingsModal').classList.remove('show');
}

// Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    assistant = new VoiceAssistant();

    // Show welcome message
    setTimeout(() => {
        assistant.voiceStatusText.textContent = 'Hello! I\'m Prime';
        assistant.voiceSubtitle.textContent = 'Say "Hey Prime" to activate me';
    }, 1000);
});
